// Generated by CoffeeScript 2.0.0-beta4
(function() {
  var client, express, http, log, polar, polar_utils, setup_app, setup_io, socketio, somata, util,
    slice = [].slice;

  socketio = require('socket.io');

  polar = require('polar');

  polar_utils = require('polar/lib/utils');

  express = require('express');

  http = require('http');

  somata = require('somata');

  util = require('util');

  ({log} = somata.helpers);

  client = new somata.Client;

  // Set up Polar using a base express server for Socket.IO to attach to
  setup_app = function(...polar_configs) {
    var app, base_app, http_server, io, polar_config;
    polar_config = polar_utils.merge_all(polar_configs);
    // Create a base express server
    base_app = express();
    http_server = http.createServer(base_app);
    io = socketio.listen(http_server);
    // Create the polar app
    polar_config.app = base_app;
    app = polar(polar_config);
    setup_io(io, polar_config);
    app.client = client;
    app.io = io;
    app.start = function(cb) {
      return http_server.listen(app.config.port, function() {
        console.log(`Listening on :${app.config.port}`);
        if (cb != null) {
          return cb();
        }
      });
    };
    return app;
  };

  // Setup Socket.io handlers for clients to make `remote` and `subscribe` calls
  setup_io = function(io, config) {
    var authenticated, needs_auth, ref;
    authenticated = {};
    needs_auth = ((ref = config.auth) != null ? ref.token_strategy : void 0) != null;
    // Handle new client socket connections
    return io.on('connection', function(socket) {
      var subscriptions;
      log.i(`[io.on connection] New connection ${socket.id}`);
      authenticated[socket.id] = false;
      subscriptions = {};
      socket.emit('hello'); // Emit a 'hello' for reconnections
      socket.on('hello', function(token) {
        if (needs_auth) {
          return config.auth.token_strategy.decode(config.auth, token, function(err, user) {
            if (err != null) {
              console.log('[authentication error]', err);
              return socket.emit('error', err);
            } else {
              console.log('[authentication user]', user);
              authenticated[socket.id] = true;
              return socket.emit('welcome', user);
            }
          });
        }
      });
      // Forward 'remote' calls
      socket.on('remote', function(service, method, ...args) {
        var cb, i, ref1;
        ref1 = args, args = 2 <= ref1.length ? slice.call(ref1, 0, i = ref1.length - 1) : (i = 0, []), cb = ref1[i++];
        if (needs_auth && !authenticated[socket.id]) {
          return;
        }
        console.log(`[io.on remote] <${socket.id}> ${service} : ${method}`);
        return client.remote(service, method, ...args, function(err, data) {
          console.log(`[io.on remote] Response from <${socket.id}> ${service} : ${method}`);
          return cb(err, data);
        });
      });
      // Forward subscriptions by emitting events back over socket
      socket.on('subscribe', function(service, type, ...args) {
        var base, handler, id, subscription;
        if (needs_auth && !authenticated[socket.id]) {
          return;
        }
        console.log(`[io.on subscribe] <${socket.id}> ${service} : ${type}`);
        id = somata.helpers.randomString(10);
        subscription = {id, service, type, args};
        subscription.cb = function(event) {
          return socket.emit('event', service, type, event);
        };
        handler = client.subscribe(subscription);
        subscriptions[service] || (subscriptions[service] = {});
        (base = subscriptions[service])[type] || (base[type] = []);
        return subscriptions[service][type].push(id);
      });
      socket.on('unsubscribe', function(service, type) {
        if (needs_auth && !authenticated[socket.id]) {
          return;
        }
        console.log('[io.on unsubscribe]', service, type);
        subscriptions[service][type].map(function(sub_id) {
          return client.unsubscribe(sub_id);
        });
        return delete subscriptions[service][type];
      });
      // Unsubscribe from all of a socket's subscriptions
      return socket.on('disconnect', function() {
        var results, service, subs, type, types;
        console.log(`[io.on disconnect] <${socket.id}>`);
        delete authenticated[socket.id];
        results = [];
        for (service in subscriptions) {
          types = subscriptions[service];
          results.push((function() {
            var results1;
            results1 = [];
            for (type in types) {
              subs = types[type];
              results1.push(subs.map(function(sub_id) {
                return client.unsubscribe(sub_id);
              }));
            }
            return results1;
          })());
        }
        return results;
      });
    });
  };

  module.exports = setup_app;

}).call(this);
