// Generated by CoffeeScript 1.12.4
(function() {
  var client, express, http, log, polar, polar_utils, setup_app, setup_io, socketio, somata, util,
    slice = [].slice;

  socketio = require('socket.io');

  polar = require('polar');

  polar_utils = require('polar/lib/utils');

  express = require('express');

  http = require('http');

  somata = require('somata');

  util = require('util');

  log = somata.helpers.log;

  client = new somata.Client;

  setup_app = function() {
    var app, base_app, http_server, io, polar_config, polar_configs;
    polar_configs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    polar_config = polar_utils.merge_all(polar_configs);
    base_app = express();
    http_server = http.createServer(base_app);
    io = socketio.listen(http_server);
    polar_config.app = base_app;
    app = polar(polar_config);
    setup_io(io, polar_config);
    app.client = client;
    app.io = io;
    app.start = function(cb) {
      return http_server.listen(app.config.port, function() {
        console.log("Listening on :" + app.config.port);
        if (cb != null) {
          return cb();
        }
      });
    };
    return app;
  };

  setup_io = function(io, config) {
    var authenticated;
    authenticated = {};
    return io.on('connection', function(socket) {
      var subscriptions;
      log.i("[io.on connection] New connection " + socket.id);
      authenticated[socket.id] = false;
      subscriptions = {};
      socket.emit('hello');
      socket.on('hello', function(token) {
        var ref, ref1;
        return (ref = config.auth) != null ? (ref1 = ref.token_strategy) != null ? ref1.decode(config.auth, token, function(err, user) {
          if (err != null) {
            console.log('[authentication error]', err);
            return socket.emit('error', err);
          } else {
            console.log('[authentication user]', user);
            authenticated[socket.id] = true;
            return socket.emit('welcome', user);
          }
        }) : void 0 : void 0;
      });
      socket.on('remote', function() {
        var args, cb, i, method, service;
        service = arguments[0], method = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), cb = arguments[i++];
        if (!authenticated[socket.id]) {
          return;
        }
        console.log("[io.on remote] <" + socket.id + "> " + service + " : " + method);
        return client.remote.apply(client, [service, method].concat(slice.call(args), [function(err, data) {
          console.log("[io.on remote] Response from <" + socket.id + "> " + service + " : " + method);
          return cb(err, data);
        }]));
      });
      socket.on('subscribe', function(service, type) {
        var base, handler, id, subscription;
        if (!authenticated[socket.id]) {
          return;
        }
        console.log("[io.on subscribe] <" + socket.id + "> " + service + " : " + type);
        id = somata.helpers.randomString(10);
        subscription = {
          id: id,
          service: service,
          type: type,
          args: []
        };
        subscription.cb = function(event) {
          return socket.emit('event', service, type, event);
        };
        handler = client.subscribe(subscription);
        subscriptions[service] || (subscriptions[service] = {});
        (base = subscriptions[service])[type] || (base[type] = []);
        return subscriptions[service][type].push(id);
      });
      socket.on('unsubscribe', function(service, type) {
        if (!authenticated[socket.id]) {
          return;
        }
        console.log('[io.on unsubscribe]', service, type);
        subscriptions[service][type].map(function(sub_id) {
          return client.unsubscribe(sub_id);
        });
        return delete subscriptions[service][type];
      });
      return socket.on('disconnect', function() {
        var results, service, subs, type, types;
        console.log("[io.on disconnect] <" + socket.id + ">");
        delete authenticated[socket.id];
        results = [];
        for (service in subscriptions) {
          types = subscriptions[service];
          results.push((function() {
            var results1;
            results1 = [];
            for (type in types) {
              subs = types[type];
              results1.push(subs.map(function(sub_id) {
                return client.unsubscribe(sub_id);
              }));
            }
            return results1;
          })());
        }
        return results;
      });
    });
  };

  module.exports = setup_app;

}).call(this);
